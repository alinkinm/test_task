package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"github.com/gofiber/fiber/v2"
	"github.com/patrickmn/go-cache"
	"strconv"
	"test_task"
	"time"

	//"github.com/jellydator/ttlcache/v2"
	"github.com/gofiber/template/html"
	_ "github.com/lib/pq"
	"github.com/nats-io/nats.go"
	"sync"
)

var i string
var id int

var ca *cache.Cache = cache.New(cache.NoExpiration, -1)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	go listen(&wg)
	go server(&wg)

	wg.Wait()

}

func listen(wg *sync.WaitGroup) {

	message := &test_task.Message{}

	db := connectToDataBase()
	row := db.QueryRow("SELECT str, id FROM simple_table order by id desc limit 1")
	switch err := row.Scan(&i, &id); err {
	case sql.ErrNoRows:
		fmt.Println("No rows were returned!")
	case nil:
		fmt.Println(id, i)
	default:
		panic(err)
	}

	defer db.Close()

	nc, _ := nats.Connect(nats.DefaultURL)

	defer nc.Close()

	nc.Subscribe("wb", func(m *nats.Msg) {
		id = id + 1
		insertStmt := "insert into simple_table(str) values ($1);"
		_, e := db.Exec(insertStmt, string(m.Data))
		CheckError(e)
		message = &test_task.Message{MessageId: id, Message: string(m.Data)}
		_, found := ca.Get(strconv.Itoa(id))
		if found {
		} else {
			ca.Set(strconv.Itoa(id), message, 5*time.Minute)
		}

	})

	Block()

}

func server(wg *sync.WaitGroup) {

	engine := html.New("subscriber/views", ".html")

	app := fiber.New(fiber.Config{
		Views: engine,
	})

	app.Get("/", func(c *fiber.Ctx) error {
		return c.Render("index", fiber.Map{})
	})

	app.Post("/", handleFormUpload)
	err := app.Listen(":8080")
	if err != nil {
		return
	}
}
func handleFormUpload(c *fiber.Ctx) error {
	ourid := c.FormValue("id")
	f1, found1 := ca.Get(ourid)
	if found1 {
		message := &test_task.Message{}
		message = f1.(*test_task.Message)
		s := message.Message
		data := test_task.AutoGenerated{}
		err := json.Unmarshal([]byte(s), &data)
		if err != nil {
			return err
		}
		return c.Render("result", fiber.Map{
			"OrderId":           data.OrderUID,
			"TrackNumber":       data.TrackNumber,
			"Entry":             data.Entry,
			"DeliveryName":      data.Delivery.Name,
			"DeliveryPhone":     data.Delivery.Phone,
			"DeliveryZip":       data.Delivery.Zip,
			"DeliveryCity":      data.Delivery.City,
			"DeliveryAdress":    data.Delivery.Address,
			"DeliveryRegion":    data.Delivery.Region,
			"DeliveryEmail":     data.Delivery.Email,
			"Transaction":       data.Payment.Transaction,
			"RequestId":         data.Payment.RequestID,
			"Currency":          data.Payment.Currency,
			"Provider":          data.Payment.Provider,
			"Amount":            data.Payment.Amount,
			"PaymentDt":         data.Payment.PaymentDt,
			"Bank":              data.Payment.Bank,
			"DeliveryCost":      data.Payment.DeliveryCost,
			"GoodsTotal":        data.Payment.GoodsTotal,
			"CustomFee":         data.Payment.CustomFee,
			"ChrtId":            data.Items[0].ChrtID,
			"ItemTrackNumber":   data.Items[0].TrackNumber,
			"ItemPrice":         data.Items[0].Price,
			"ItemRid":           data.Items[0].Rid,
			"ItemName":          data.Items[0].Name,
			"ItemSale":          data.Items[0].Sale,
			"ItemSize":          data.Items[0].Size,
			"ItemTotalPrize":    data.Items[0].TotalPrice,
			"NmID":              data.Items[0].NmID,
			"Brand":             data.Items[0].Brand,
			"Status":            data.Items[0].Status,
			"Locale":            data.Locale,
			"InternalSignature": data.InternalSignature,
			"CustomerID":        data.CustomerID,
			"DeliveryService":   data.DeliveryService,
			"ShardKey":          data.Shardkey,
			"SmID":              data.SmID,
			"DateCreated":       data.DateCreated,
			"OofShard":          data.OofShard,
		})
	} else {
		return c.SendString("no data found for this id ðŸ¥³")
	}
	return nil
}

func Block() {
	w := sync.WaitGroup{}
	w.Add(1)
	w.Wait()
}

func CheckError(err error) {
	if err != nil {
		panic(err)
	}
}
